{
  "version": 3,
  "sources": ["../../../src/rendering-util/handle-markdown-text.ts", "../../../src/rendering-util/splitText.ts", "../../../src/rendering-util/createText.ts"],
  "sourcesContent": ["import type { Content } from 'mdast';\nimport { fromMarkdown } from 'mdast-util-from-markdown';\nimport { dedent } from 'ts-dedent';\nimport type { MarkdownLine, MarkdownWordType } from './types.js';\nimport type { MermaidConfig } from '../config.type.js';\n\n/**\n * @param markdown - markdown to process\n * @returns processed markdown\n */\nfunction preprocessMarkdown(markdown: string, { markdownAutoWrap }: MermaidConfig): string {\n  // Replace multiple newlines with a single newline\n  const withoutMultipleNewlines = markdown.replace(/\\n{2,}/g, '\\n');\n  // Remove extra spaces at the beginning of each line\n  const withoutExtraSpaces = dedent(withoutMultipleNewlines);\n  if (markdownAutoWrap === false) {\n    return withoutExtraSpaces.replace(/ /g, '&nbsp;');\n  }\n  return withoutExtraSpaces;\n}\n\n/**\n * @param markdown - markdown to split into lines\n */\nexport function markdownToLines(markdown: string, config: MermaidConfig = {}): MarkdownLine[] {\n  const preprocessedMarkdown = preprocessMarkdown(markdown, config);\n  const { children } = fromMarkdown(preprocessedMarkdown);\n  const lines: MarkdownLine[] = [[]];\n  let currentLine = 0;\n\n  function processNode(node: Content, parentType: MarkdownWordType = 'normal') {\n    if (node.type === 'text') {\n      const textLines = node.value.split('\\n');\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n        textLine.split(' ').forEach((word) => {\n          if (word) {\n            lines[currentLine].push({ content: word, type: parentType });\n          }\n        });\n      });\n    } else if (node.type === 'strong' || node.type === 'emphasis') {\n      node.children.forEach((contentNode) => {\n        processNode(contentNode, node.type);\n      });\n    }\n  }\n\n  children.forEach((treeNode) => {\n    if (treeNode.type === 'paragraph') {\n      treeNode.children.forEach((contentNode) => {\n        processNode(contentNode);\n      });\n    }\n  });\n\n  return lines;\n}\n\nexport function markdownToHTML(markdown: string, { markdownAutoWrap }: MermaidConfig = {}) {\n  const { children } = fromMarkdown(markdown);\n\n  function output(node: Content): string {\n    if (node.type === 'text') {\n      if (markdownAutoWrap === false) {\n        return node.value.replace(/\\n/g, '<br/>').replace(/ /g, '&nbsp;');\n      }\n      return node.value.replace(/\\n/g, '<br/>');\n    } else if (node.type === 'strong') {\n      return `<strong>${node.children.map(output).join('')}</strong>`;\n    } else if (node.type === 'emphasis') {\n      return `<em>${node.children.map(output).join('')}</em>`;\n    } else if (node.type === 'paragraph') {\n      return `<p>${node.children.map(output).join('')}</p>`;\n    }\n    return `Unsupported markdown: ${node.type}`;\n  }\n\n  return children.map(output).join('');\n}\n", "import type { CheckFitFunction, MarkdownLine, MarkdownWord, MarkdownWordType } from './types.js';\n\n/**\n * Splits a string into graphemes if available, otherwise characters.\n */\nexport function splitTextToChars(text: string): string[] {\n  if (Intl.Segmenter) {\n    return [...new Intl.Segmenter().segment(text)].map((s) => s.segment);\n  }\n  return [...text];\n}\n\n/**\n * Splits a string into words by using `Intl.Segmenter` if available, or splitting by ' '.\n * `Intl.Segmenter` uses the default locale, which might be different across browsers.\n */\nexport function splitLineToWords(text: string): string[] {\n  if (Intl.Segmenter) {\n    return [...new Intl.Segmenter(undefined, { granularity: 'word' }).segment(text)].map(\n      (s) => s.segment\n    );\n  }\n  // Split by ' ' removes the ' 's from the result.\n  const words = text.split(' ');\n  // Add the ' 's back to the result.\n  const wordsWithSpaces = words.flatMap((s) => [s, ' ']).filter((s) => s);\n  // Remove last space.\n  wordsWithSpaces.pop();\n  return wordsWithSpaces;\n}\n\n/**\n * Splits a word into two parts, the first part fits the width and the remaining part.\n * @param checkFit - Function to check if word fits\n * @param word - Word to split\n * @returns [first part of word that fits, rest of word]\n */\nexport function splitWordToFitWidth(\n  checkFit: CheckFitFunction,\n  word: MarkdownWord\n): [MarkdownWord, MarkdownWord] {\n  const characters = splitTextToChars(word.content);\n  return splitWordToFitWidthRecursion(checkFit, [], characters, word.type);\n}\n\nfunction splitWordToFitWidthRecursion(\n  checkFit: CheckFitFunction,\n  usedChars: string[],\n  remainingChars: string[],\n  type: MarkdownWordType\n): [MarkdownWord, MarkdownWord] {\n  if (remainingChars.length === 0) {\n    return [\n      { content: usedChars.join(''), type },\n      { content: '', type },\n    ];\n  }\n  const [nextChar, ...rest] = remainingChars;\n  const newWord = [...usedChars, nextChar];\n  if (checkFit([{ content: newWord.join(''), type }])) {\n    return splitWordToFitWidthRecursion(checkFit, newWord, rest, type);\n  }\n  if (usedChars.length === 0 && nextChar) {\n    // If the first character does not fit, split it anyway\n    usedChars.push(nextChar);\n    remainingChars.shift();\n  }\n  return [\n    { content: usedChars.join(''), type },\n    { content: remainingChars.join(''), type },\n  ];\n}\n\n/**\n * Splits a line into multiple lines that satisfy the checkFit function.\n * @param line - Line to split\n * @param checkFit - Function to check if line fits\n * @returns Array of lines that fit\n */\nexport function splitLineToFitWidth(\n  line: MarkdownLine,\n  checkFit: CheckFitFunction\n): MarkdownLine[] {\n  if (line.some(({ content }) => content.includes('\\n'))) {\n    throw new Error('splitLineToFitWidth does not support newlines in the line');\n  }\n  return splitLineToFitWidthRecursion(line, checkFit);\n}\n\nfunction splitLineToFitWidthRecursion(\n  words: MarkdownWord[],\n  checkFit: CheckFitFunction,\n  lines: MarkdownLine[] = [],\n  newLine: MarkdownLine = []\n): MarkdownLine[] {\n  // Return if there is nothing left to split\n  if (words.length === 0) {\n    // If there is a new line, add it to the lines\n    if (newLine.length > 0) {\n      lines.push(newLine);\n    }\n    return lines.length > 0 ? lines : [];\n  }\n  let joiner = '';\n  if (words[0].content === ' ') {\n    joiner = ' ';\n    words.shift();\n  }\n  const nextWord: MarkdownWord = words.shift() ?? { content: ' ', type: 'normal' };\n  const lineWithNextWord: MarkdownLine = [...newLine];\n  if (joiner !== '') {\n    lineWithNextWord.push({ content: joiner, type: 'normal' });\n  }\n  lineWithNextWord.push(nextWord);\n\n  if (checkFit(lineWithNextWord)) {\n    // nextWord fits, so we can add it to the new line and continue\n    return splitLineToFitWidthRecursion(words, checkFit, lines, lineWithNextWord);\n  }\n\n  // nextWord doesn't fit, so we need to split it\n  if (newLine.length > 0) {\n    // There was text in newLine, so add it to lines and push nextWord back into words.\n    lines.push(newLine);\n    words.unshift(nextWord);\n  } else if (nextWord.content) {\n    // There was no text in newLine, so we need to split nextWord\n    const [line, rest] = splitWordToFitWidth(checkFit, nextWord);\n    lines.push([line]);\n    if (rest.content) {\n      words.unshift(rest);\n    }\n  }\n  return splitLineToFitWidthRecursion(words, checkFit, lines);\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n// @ts-nocheck TODO: Fix types\nimport type { MermaidConfig } from '../config.type.js';\nimport type { Group } from '../diagram-api/types.js';\nimport type { D3TSpanElement, D3TextElement } from '../diagrams/common/commonTypes.js';\nimport { log } from '../logger.js';\nimport { markdownToHTML, markdownToLines } from '../rendering-util/handle-markdown-text.js';\nimport { decodeEntities } from '../utils.js';\nimport { splitLineToFitWidth } from './splitText.js';\nimport type { MarkdownLine, MarkdownWord } from './types.js';\n\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr('style', styleFn);\n  }\n}\n\nfunction addHtmlSpan(element, node, width, classes, addBackground = false) {\n  const fo = element.append('foreignObject');\n  const div = fo.append('xhtml:div');\n\n  const label = node.label;\n  const labelClass = node.isNode ? 'nodeLabel' : 'edgeLabel';\n  div.html(\n    `<span class=\"${labelClass} ${classes}\" ` +\n      (node.labelStyle ? 'style=\"' + node.labelStyle + '\"' : '') +\n      '>' +\n      label +\n      '</span>'\n  );\n\n  applyStyle(div, node.labelStyle);\n  div.style('display', 'table-cell');\n  div.style('white-space', 'nowrap');\n  div.style('max-width', width + 'px');\n  div.attr('xmlns', 'http://www.w3.org/1999/xhtml');\n  if (addBackground) {\n    div.attr('class', 'labelBkg');\n  }\n\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style('display', 'table');\n    div.style('white-space', 'break-spaces');\n    div.style('width', width + 'px');\n    bbox = div.node().getBoundingClientRect();\n  }\n\n  fo.style('width', bbox.width);\n  fo.style('height', bbox.height);\n\n  return fo.node();\n}\n\n/**\n * Creates a tspan element with the specified attributes for text positioning.\n *\n * @param textElement - The parent text element to append the tspan element.\n * @param lineIndex - The index of the current line in the structuredText array.\n * @param lineHeight - The line height value for the text.\n * @returns The created tspan element.\n */\nfunction createTspan(textElement: any, lineIndex: number, lineHeight: number) {\n  return textElement\n    .append('tspan')\n    .attr('class', 'text-outer-tspan')\n    .attr('x', 0)\n    .attr('y', lineIndex * lineHeight - 0.1 + 'em')\n    .attr('dy', lineHeight + 'em');\n}\n\nfunction computeWidthOfText(parentNode: any, lineHeight: number, line: MarkdownLine): number {\n  const testElement = parentNode.append('text');\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, line);\n  const textLength = testSpan.node().getComputedTextLength();\n  testElement.remove();\n  return textLength;\n}\n\nexport function computeDimensionOfText(\n  parentNode: Group,\n  lineHeight: number,\n  text: string\n): DOMRect | undefined {\n  const testElement: D3TextElement = parentNode.append('text');\n  const testSpan: D3TSpanElement = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, [{ content: text, type: 'normal' }]);\n  const textDimension: DOMRect | undefined = testSpan.node()?.getBoundingClientRect();\n  if (textDimension) {\n    testElement.remove();\n  }\n  return textDimension;\n}\n\n/**\n * Creates a formatted text element by breaking lines and applying styles based on\n * the given structuredText.\n *\n * @param width - The maximum allowed width of the text.\n * @param g - The parent group element to append the formatted text.\n * @param structuredText - The structured text data to format.\n * @param addBackground - Whether to add a background to the text.\n */\nfunction createFormattedText(\n  width: number,\n  g: any,\n  structuredText: MarkdownWord[][],\n  addBackground = false\n) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append('g');\n  const bkg = labelGroup.insert('rect').attr('class', 'background');\n  const textElement = labelGroup.append('text').attr('y', '-10.1');\n  let lineIndex = 0;\n  for (const line of structuredText) {\n    /**\n     * Preprocess raw string content of line data\n     * Creating an array of strings pre-split to satisfy width limit\n     */\n    const checkWidth = (line: MarkdownLine) =>\n      computeWidthOfText(labelGroup, lineHeight, line) <= width;\n    const linesUnderWidth = checkWidth(line) ? [line] : splitLineToFitWidth(line, checkWidth);\n    /** Add each prepared line as a tspan to the parent node */\n    for (const preparedLine of linesUnderWidth) {\n      const tspan = createTspan(textElement, lineIndex, lineHeight);\n      updateTextContentAndStyles(tspan, preparedLine);\n      lineIndex++;\n    }\n  }\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg\n      .attr('x', -padding)\n      .attr('y', -padding)\n      .attr('width', bbox.width + 2 * padding)\n      .attr('height', bbox.height + 2 * padding);\n\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\n\n/**\n * Updates the text content and styles of the given tspan element based on the\n * provided wrappedLine data.\n *\n * @param tspan - The tspan element to update.\n * @param wrappedLine - The line data to apply to the tspan element.\n */\nfunction updateTextContentAndStyles(tspan: any, wrappedLine: MarkdownWord[]) {\n  tspan.text('');\n\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan\n      .append('tspan')\n      .attr('font-style', word.type === 'emphasis' ? 'italic' : 'normal')\n      .attr('class', 'text-inner-tspan')\n      .attr('font-weight', word.type === 'strong' ? 'bold' : 'normal');\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      // TODO: check what joiner to use.\n      innerTspan.text(' ' + word.content);\n    }\n  });\n}\n\n/**\n * Convert fontawesome labels into fontawesome icons by using a regex pattern\n * @param text - The raw string to convert\n * @returns string with fontawesome icons as i tags\n */\nexport function replaceIconSubstring(text: string) {\n  // The letters 'bklrs' stand for possible endings of the fontawesome prefix (e.g. 'fab' for brands, 'fak' for fa-kit) // cspell: disable-line\n  return text.replace(\n    /fa[bklrs]?:fa-[\\w-]+/g, // cspell: disable-line\n    (s) => `<i class='${s.replace(':', ' ')}'></i>`\n  );\n}\n\n// Note when using from flowcharts converting the API isNode means classes should be set accordingly. When using htmlLabels => to sett classes to'nodeLabel' when isNode=true otherwise 'edgeLabel'\n// When not using htmlLabels => to set classes to 'title-row' when isTitle=true otherwise 'title-row'\nexport const createText = (\n  el,\n  text = '',\n  {\n    style = '',\n    isTitle = false,\n    classes = '',\n    useHtmlLabels = true,\n    isNode = true,\n    width = 200,\n    addSvgBackground = false,\n  } = {},\n  config: MermaidConfig\n) => {\n  log.info('createText', text, style, isTitle, classes, useHtmlLabels, isNode, addSvgBackground);\n  if (useHtmlLabels) {\n    // TODO: addHtmlLabel accepts a labelStyle. Do we possibly have that?\n\n    const htmlText = markdownToHTML(text, config);\n    const decodedReplacedText = replaceIconSubstring(decodeEntities(htmlText));\n    const node = {\n      isNode,\n      label: decodedReplacedText,\n      labelStyle: style.replace('fill:', 'color:'),\n    };\n    const vertexNode = addHtmlSpan(el, node, width, classes, addSvgBackground);\n    return vertexNode;\n  } else {\n    const structuredText = markdownToLines(text, config);\n    const svgLabel = createFormattedText(width, el, structuredText, addSvgBackground);\n    return svgLabel;\n  }\n};\n"],
  "mappings": "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",
  "names": ["line"]
}
