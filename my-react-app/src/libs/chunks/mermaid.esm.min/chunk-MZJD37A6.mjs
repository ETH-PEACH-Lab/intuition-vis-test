import{a as U,b as G,c as A,d as X,e as j,f as H,g as V,h as _,i as B,j as W,k as q,l as z,m as K}from"./chunk-6PBAZYZY.mjs";import{c as $}from"./chunk-4DYLSDN7.mjs";import{a as M}from"./chunk-M5RPCIO7.mjs";import{a as R}from"./chunk-AUXUJQO7.mjs";import{D as C,e as F,s as P}from"./chunk-VMDNBU76.mjs";import{Ta as S,b as r,ca as N,h as L}from"./chunk-3RIG7DRU.mjs";import{a as u}from"./chunk-J73WXDYM.mjs";function w(n){var t={options:{directed:n.isDirected(),multigraph:n.isMultigraph(),compound:n.isCompound()},nodes:lt(n),edges:ft(n)};return C(n.graph())||(t.value=F(n.graph())),t}u(w,"write");function lt(n){return P(n.nodes(),function(t){var e=n.node(t),s=n.parent(t),i={v:t};return C(e)||(i.value=e),C(s)||(i.parent=s),i})}u(lt,"writeNodes");function ft(n){return P(n.edges(),function(t){var e=n.edge(t),s={v:t.v,w:t.w};return C(t.name)||(s.name=t.name),C(e)||(s.value=e),s})}u(ft,"writeEdges");var l={},m={},Y={},Z=u(()=>{m={},Y={},l={}},"clear"),D=u((n,t)=>(r.trace("In isDescendant",t," ",n," = ",m[t].includes(n)),!!m[t].includes(n)),"isDescendant"),dt=u((n,t)=>(r.info("Descendants of ",t," is ",m[t]),r.info("Edge is ",n),n.v===t||n.w===t?!1:m[t]?m[t].includes(n.v)||D(n.v,t)||D(n.w,t)||m[t].includes(n.w):(r.debug("Tilt, ",t,",not in descendants"),!1)),"edgeInCluster"),I=u((n,t,e,s)=>{r.warn("Copying children of ",n,"root",s,"data",t.node(n),s);let i=t.children(n)||[];n!==s&&i.push(n),r.warn("Copying (nodes) clusterId",n,"nodes",i),i.forEach(o=>{if(t.children(o).length>0)I(o,t,e,s);else{let d=t.node(o);r.info("cp ",o," to ",s," with parent ",n),e.setNode(o,d),s!==t.parent(o)&&(r.warn("Setting parent",o,t.parent(o)),e.setParent(o,t.parent(o))),n!==s&&o!==n?(r.debug("Setting parent",o,n),e.setParent(o,n)):(r.info("In copy ",n,"root",s,"data",t.node(n),s),r.debug("Not Setting parent for node=",o,"cluster!==rootId",n!==s,"node!==clusterId",o!==n));let h=t.edges(o);r.debug("Copying Edges",h),h.forEach(f=>{r.info("Edge",f);let g=t.edge(f.v,f.w,f.name);r.info("Edge data",g,s);try{dt(f,s)?(r.info("Copying as ",f.v,f.w,g,f.name),e.setEdge(f.v,f.w,g,f.name),r.info("newGraph edges ",e.edges(),e.edge(e.edges()[0]))):r.info("Skipping copy of edge ",f.v,"-->",f.w," rootId: ",s," clusterId:",n)}catch(x){r.error(x)}})}r.debug("Removing node",o),t.removeNode(o)})},"copy"),tt=u((n,t)=>{let e=t.children(n),s=[...e];for(let i of e)Y[i]=n,s=[...s,...tt(i,t)];return s},"extractDescendants");var E=u((n,t)=>{r.trace("Searching",n);let e=t.children(n);if(r.trace("Searching children of id ",n,e),e.length<1)return r.trace("This is a valid node",n),n;for(let s of e){let i=E(s,t);if(i)return r.trace("Found replacement for",n," => ",i),i}},"findNonClusterChild"),T=u(n=>!l[n]||!l[n].externalConnections?n:l[n]?l[n].id:n,"getAnchorId"),et=u((n,t)=>{if(!n||t>10){r.debug("Opting out, no graph ");return}else r.debug("Opting in, graph ");n.nodes().forEach(function(e){n.children(e).length>0&&(r.warn("Cluster identified",e," Replacement id in edges: ",E(e,n)),m[e]=tt(e,n),l[e]={id:E(e,n),clusterData:n.node(e)})}),n.nodes().forEach(function(e){let s=n.children(e),i=n.edges();s.length>0?(r.debug("Cluster identified",e,m),i.forEach(o=>{if(o.v!==e&&o.w!==e){let d=D(o.v,e),h=D(o.w,e);d^h&&(r.warn("Edge: ",o," leaves cluster ",e),r.warn("Descendants of XXX ",e,": ",m[e]),l[e].externalConnections=!0)}})):r.debug("Not a cluster ",e,m)});for(let e of Object.keys(l)){let s=l[e].id,i=n.parent(s);i!==e&&l[i]&&!l[i].externalConnections&&(l[e].id=i)}n.edges().forEach(function(e){let s=n.edge(e);r.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),r.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(n.edge(e)));let i=e.v,o=e.w;if(r.warn("Fix XXX",l,"ids:",e.v,e.w,"Translating: ",l[e.v]," --- ",l[e.w]),l[e.v]&&l[e.w]&&l[e.v]===l[e.w]){r.warn("Fixing and trixing link to self - removing XXX",e.v,e.w,e.name),r.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),i=T(e.v),o=T(e.w),n.removeEdge(e.v,e.w,e.name);let d=e.w+"---"+e.v;n.setNode(d,{domId:d,id:d,labelStyle:"",labelText:s.label,padding:0,shape:"labelRect",style:""});let h=structuredClone(s),f=structuredClone(s);h.label="",h.arrowTypeEnd="none",f.label="",h.fromCluster=e.v,f.toCluster=e.v,n.setEdge(i,d,h,e.name+"-cyclic-special"),n.setEdge(d,o,f,e.name+"-cyclic-special")}else if(l[e.v]||l[e.w]){if(r.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),i=T(e.v),o=T(e.w),n.removeEdge(e.v,e.w,e.name),i!==e.v){let d=n.parent(i);l[d].externalConnections=!0,s.fromCluster=e.v}if(o!==e.w){let d=n.parent(o);l[d].externalConnections=!0,s.toCluster=e.w}r.warn("Fix Replacing with XXX",i,o,e.name),n.setEdge(i,o,s,e.name)}}),r.warn("Adjusted Graph",w(n)),nt(n,0),r.trace(l)},"adjustClustersAndEdges"),nt=u((n,t)=>{if(r.warn("extractor - ",t,w(n),n.children("D")),t>10){r.error("Bailing out");return}let e=n.nodes(),s=!1;for(let i of e){let o=n.children(i);s=s||o.length>0}if(!s){r.debug("Done, no node has children",n.nodes());return}r.debug("Nodes = ",e,t);for(let i of e)if(r.debug("Extracting node",i,l,l[i]&&!l[i].externalConnections,!n.parent(i),n.node(i),n.children("D")," Depth ",t),!l[i])r.debug("Not a cluster",i,t);else if(!l[i].externalConnections&&n.children(i)&&n.children(i).length>0){r.warn("Cluster without external connections, without a parent and with children",i,t);let d=n.graph().rankdir==="TB"?"LR":"TB";l[i]&&l[i].clusterData&&l[i].clusterData.dir&&(d=l[i].clusterData.dir,r.warn("Fixing dir",l[i].clusterData.dir,d));let h=new R({multigraph:!0,compound:!0}).setGraph({rankdir:d,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});r.warn("Old graph before copy",w(n)),I(i,n,h,i),n.setNode(i,{clusterNode:!0,id:i,clusterData:l[i].clusterData,labelText:l[i].labelText,graph:h}),r.warn("New graph after copy node: (",i,")",w(h)),r.debug("Old graph after copy",w(n))}else r.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!l[i].externalConnections," no parent: ",!n.parent(i)," children ",n.children(i)&&n.children(i).length>0,n.children("D"),t),r.debug(l);e=n.nodes(),r.warn("New list of nodes",e);for(let i of e){let o=n.node(i);r.warn(" Now next level",i,o),o.clusterNode&&nt(o.graph,t+1)}},"extractor"),it=u((n,t)=>{if(t.length===0)return[];let e=Object.assign(t);return t.forEach(s=>{let i=n.children(s),o=it(n,i);e=[...e,...o]}),e},"sorter"),rt=u(n=>it(n,n.children()),"sortNodesByHierarchy");var ht=u((n,t)=>{r.info("Creating subgraph rect for ",t.id,t);let e=S(),s=n.insert("g").attr("class","cluster"+(t.class?" "+t.class:"")).attr("id",t.id),i=s.insert("rect",":first-child"),o=N(e.flowchart.htmlLabels),d=s.insert("g").attr("class","cluster-label"),h=t.labelType==="markdown"?$(d,t.labelText,{style:t.labelStyle,useHtmlLabels:o},e):d.node().appendChild(G(t.labelText,t.labelStyle,void 0,!0)),f=h.getBBox();if(N(e.flowchart.htmlLabels)){let a=h.children[0],c=L(h);f=a.getBoundingClientRect(),c.attr("width",f.width),c.attr("height",f.height)}let g=0*t.padding,x=g/2,p=t.width<=f.width+g?f.width+g:t.width;t.width<=f.width+g?t.diff=(f.width-t.width)/2-t.padding/2:t.diff=-t.padding/2,r.trace("Data ",t,JSON.stringify(t)),i.attr("style",t.style).attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-p/2).attr("y",t.y-t.height/2-x).attr("width",p).attr("height",t.height+g);let{subGraphTitleTopMargin:v}=B(e);o?d.attr("transform",`translate(${t.x-f.width/2}, ${t.y-t.height/2+v})`):d.attr("transform",`translate(${t.x}, ${t.y-t.height/2+v})`);let b=i.node().getBBox();return t.width=b.width,t.height=b.height,t.intersect=function(a){return X(t,a)},s},"rect"),ut=u((n,t)=>{let e=n.insert("g").attr("class","note-cluster").attr("id",t.id),s=e.insert("rect",":first-child"),i=0*t.padding,o=i/2;s.attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-t.width/2-o).attr("y",t.y-t.height/2-o).attr("width",t.width+i).attr("height",t.height+i).attr("fill","none");let d=s.node().getBBox();return t.width=d.width,t.height=d.height,t.intersect=function(h){return X(t,h)},e},"noteGroup"),gt=u((n,t)=>{let e=S(),s=n.insert("g").attr("class",t.classes).attr("id",t.id),i=s.insert("rect",":first-child"),o=s.insert("g").attr("class","cluster-label"),d=s.append("rect"),h=o.node().appendChild(G(t.labelText,t.labelStyle,void 0,!0)),f=h.getBBox();if(N(e.flowchart.htmlLabels)){let a=h.children[0],c=L(h);f=a.getBoundingClientRect(),c.attr("width",f.width),c.attr("height",f.height)}f=h.getBBox();let g=0*t.padding,x=g/2,p=t.width<=f.width+t.padding?f.width+t.padding:t.width;t.width<=f.width+t.padding?t.diff=(f.width+t.padding*0-t.width)/2:t.diff=-t.padding/2,i.attr("class","outer").attr("x",t.x-p/2-x).attr("y",t.y-t.height/2-x).attr("width",p+g).attr("height",t.height+g),d.attr("class","inner").attr("x",t.x-p/2-x).attr("y",t.y-t.height/2-x+f.height-1).attr("width",p+g).attr("height",t.height+g-f.height-3);let{subGraphTitleTopMargin:v}=B(e);o.attr("transform",`translate(${t.x-f.width/2}, ${t.y-t.height/2-t.padding/3+(N(e.flowchart.htmlLabels)?5:3)+v})`);let b=i.node().getBBox();return t.height=b.height,t.intersect=function(a){return X(t,a)},s},"roundedWithTitle"),wt=u((n,t)=>{let e=n.insert("g").attr("class",t.classes).attr("id",t.id),s=e.insert("rect",":first-child"),i=0*t.padding,o=i/2;s.attr("class","divider").attr("x",t.x-t.width/2-o).attr("y",t.y-t.height/2).attr("width",t.width+i).attr("height",t.height+i);let d=s.node().getBBox();return t.width=d.width,t.height=d.height,t.diff=-t.padding/2,t.intersect=function(h){return X(t,h)},e},"divider"),mt={rect:ht,roundedWithTitle:gt,noteGroup:ut,divider:wt},st={},ot=u((n,t)=>{r.trace("Inserting cluster");let e=t.shape||"rect";st[t.id]=mt[e](n,t)},"insertCluster");var at=u(()=>{st={}},"clear");var ct=u(async(n,t,e,s,i,o)=>{r.info("Graph in recursive render: XXX",w(t),i);let d=t.graph().rankdir;r.trace("Dir in recursive render - dir:",d);let h=n.insert("g").attr("class","root");t.nodes()?r.info("Recursive render XXX",t.nodes()):r.info("No nodes found for",t),t.edges().length>0&&r.trace("Recursive edges",t.edge(t.edges()[0]));let f=h.insert("g").attr("class","clusters"),g=h.insert("g").attr("class","edgePaths"),x=h.insert("g").attr("class","edgeLabels"),p=h.insert("g").attr("class","nodes");await Promise.all(t.nodes().map(async function(a){let c=t.node(a);if(i!==void 0){let y=JSON.parse(JSON.stringify(i.clusterData));r.info("Setting data for cluster XXX (",a,") ",y,i),t.setNode(i.id,y),t.parent(a)||(r.trace("Setting parent",a,i.id),t.setParent(a,i.id,y))}if(r.info("(Insert) Node XXX"+a+": "+JSON.stringify(t.node(a))),c&&c.clusterNode){r.info("Cluster identified",a,c.width,t.node(a));let{ranksep:y,nodesep:J}=t.graph();c.graph.setGraph({...c.graph.graph(),ranksep:y,nodesep:J});let k=await ct(p,c.graph,e,s,t.node(a),o),O=k.elem;A(c,O),c.diff=k.diff||0,r.info("Node bounds (abc123)",a,c,c.width,c.x,c.y),H(O,c),r.warn("Recursive render complete ",O,c)}else t.children(a).length>0?(r.info("Cluster - the non recursive path XXX",a,c.id,c,t),r.info(E(c.id,t)),l[c.id]={id:E(c.id,t),node:c}):(r.info("Node - the non recursive path",a,c.id,c),await j(p,t.node(a),d))})),t.edges().forEach(function(a){let c=t.edge(a.v,a.w,a.name);r.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(a)),r.info("Edge "+a.v+" -> "+a.w+": ",a," ",JSON.stringify(t.edge(a))),r.info("Fix",l,"ids:",a.v,a.w,"Translating: ",l[a.v],l[a.w]),q(x,c)}),t.edges().forEach(function(a){r.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(a))}),r.info("#############################################"),r.info("###                Layout                 ###"),r.info("#############################################"),r.info(t),M(t),r.info("Graph after layout:",w(t));let v=0,{subGraphTitleTotalMargin:b}=B(o);return rt(t).forEach(function(a){let c=t.node(a);r.info("Position "+a+": "+JSON.stringify(t.node(a))),r.info("Position "+a+": ("+c.x,","+c.y,") width: ",c.width," height: ",c.height),c&&c.clusterNode?(c.y+=b,_(c)):t.children(a).length>0?(c.height+=b,ot(f,c),l[c.id].node=c):(c.y+=b/2,_(c))}),t.edges().forEach(function(a){let c=t.edge(a);r.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(c),c),c.points.forEach(J=>J.y+=b/2);let y=K(g,a,c,l,e,t,s);z(c,y)}),t.nodes().forEach(function(a){let c=t.node(a);r.info(a,c.type,c.diff),c.type==="group"&&(v=c.diff)}),{elem:h,diff:v}},"recursiveRender"),Vt=u(async(n,t,e,s,i)=>{U(n,e,s,i),V(),W(),at(),Z(),r.warn("Graph at first:",JSON.stringify(w(t))),et(t),r.warn("Graph after:",JSON.stringify(w(t)));let o=S();await ct(n,t,s,i,void 0,o)},"render");export{Vt as a};
